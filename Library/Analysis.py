####################################################################################################################################################  
#                                                                                                                                                  #
# This file has been generated by Amit Patankar:                                                                                                   #
#     Created by              : amit.patankar                                                                                                      #    
#     Created on              : 17-04-2014                                                                                                         #
#     Directory               : /Progs/Excelerate/Library                                                                                          #
#     Purpose                 : This structure holds the information required for fatigue and inconsistency.                                       #
#                                                                                                                                                  #
####################################################################################################################################################

from Values import *
import csv

#Algorithm: Measure large drops in performance type.
class Inconsistency(object):

    #This is the default constructor that calculates inconsistency information.
    def __init__(self):
        self.result = {}
        self.score_array = {}
        for qtype in TYPE_ARRAY:
            self.result[qtype] = False
            self.score_array[qtype] = []

    #This method extracts the scores from the users tests taken.
    def calculate(self, tests_taken):
        for test in tests_taken:
            for qtype in TYPE_ARRAY:
                self.score_array[qtype].append((test.test_id, test.score_summary.section_scores[qtype]))

    #This method analyzes the average drops and compares them to the bar.
    def analyze(self, array):
        drop_array = []
        if len(array) <= 1:
            return drop_array
        s = 0
        for item in array:
            s += item[1]
        s = s // len(array)
        for i in range(0,len(array) - 1):
            start = i
            end = i+1
            difference = array[end][1] - array[start][1]
            if difference <= -INCONSISTENCY_BAR:
                drop_array.append(Drop(array[start][0], array[end][0], difference))
        return self.advice(drop_array)

    #This method provides an advice string.
    def advice(self, drop_array):
        drop_length = len(drop_array)
        max_drop = 0
        for drop in drop_array:
            if drop.drop <= max_drop:
                max_drop = drop
        advice = ''
        if len(drop_array) > 1:
            advice += "You have multiple inconsistent drops in your performance. "
        advice += "Your performance in this category is a little inconsistent fell by " + str(-max_drop.drop) + " from " + max_drop.start + " to " + max_drop.end + "."
        return advice


class Drop(object):

    def __init__(self, startcode, endcode, drop_value):
        self.start = startcode
        self.end = endcode
        self.drop = drop_value


class Fatigue(object):

    def __init__(self):
        self.value = {}
        self.sections = {}
        for qtype in TYPE_ARRAY:
            self.value[qtype] = []
            self.sections[qtype] = []


    def calculate():
        last_score = 1
        for qtype in TYPE_ARRAY:
            fatigue_test = True
            for value in self.sections:
                if value < last_score:
        
        self.value[qtype] = True


class Test_Fatigue(object):

    def __init__(self):
        self.writing_fatigue = None
        self.reading_fatigue = None
        self.math_fatigue = None

    def calculate(self, test_taken):
        test_id = test_taken.test_id
        key = {}
        for q in TYPE_ARRAY:
            key[q] = {}
        with open(filename, 'rU') as f:
            reader = csv.reader(f)
            for row in reader:
                if row != KEY_VECTOR:
                    key[row[KEY_TYPE]][KEY_INDEX] = KEY_SIZE
        for qtype in TYPE_ARRAY:
            for question in test_taken.missed_questions[qtype]:
                print ("hi")


                








