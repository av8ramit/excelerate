####################################################################################################################################################  
#                                                                                                                                                  #
# This file has been generated by Amit Patankar:                                                                                                   #
#     Created by              : amit.patankar                                                                                                      #    
#     Created on              : 17-04-2014                                                                                                         #
#     Directory               : /Progs/Excelerate/Library                                                                                          #
#     Purpose                 : This structure converts the Excel file into our text file                                                              #
#                                                                                                                                                  #
####################################################################################################################################################

from Values import *
from Scored import *
from Commands import *
from User import *
from os import *
import csv
import shutil

#Base Elite Class Class

TEST_ID_INDEX = 0
STUDENT_ID_INDEX = 1
TEST_DATE_INDEX = 2
FORM_CODE = 3
MATH_INDEX = 5
READING_INDEX = 6
ESSAY_INDEX = 7
WRITING_INDEX = 8
SECTION_1 = 9
SECTION_2 = 10
SECTION_3 = 11
SECTION_4 = 12
SECTION_5 = 13
SECTION_6 = 14
SECTION_7 = 15
SECTION_8 = 16
SECTION_9 = 17
SECTION_10 = 18
DIFFERENCE = 8
GRID_1 = 19
GRID_2 = 20
GRID_3 = 21
GRID_4 = 22
GRID_5 = 23
GRID_6 = 24
GRID_7 = 25
GRID_8 = 26
GRID_9 = 27
GRID_10 = 28
MATH_SCALED = 38
READING_SCALED = 39
WRITING_SCALED = 40
GRIGHT1 = 59
GRIGHT2 = 60
GRIGHT3 = 61
GRIGHT4 = 62
GRIGHT5 = 63
GRIGHT6 = 64
GRIGHT7 = 65
GRIGHT8 = 66
GRIGHT9 = 67
GRIGHT10 = 68

class Elite_Class(object):

    def __init__(self, filename):
        self.students = {}
        self.valid_tests = list_tests()
        self.averages = {}
        self.elite_scores = {}
        self.invalid_rows = []

        self.convert_database(filename)


    def convert_database(self, filename):
        #n = 0
        with open(filename, 'rU') as f:
            reader = csv.reader(f)
            waive_array = [26, 555, 438, 564, 231, 228, 246, 265, 404]
            for row in reader:
                SID = row[STUDENT_ID_INDEX]
                if not self.valid_row(row):
                    self.invalid_rows.append(row)
                    continue
                if int(row[0]) in waive_array:
                    continue
                if SID not in self.students.keys():
                    self.students[SID] = User(SID, 'Elite')
                if SID not in self.elite_scores.keys():
                    self.elite_scores[SID] = []
                #n+=1
                userid = row[STUDENT_ID_INDEX]
                test_id = row[FORM_CODE]
                test_date = date_converter(row[TEST_DATE_INDEX])

                if test_date not in self.averages.keys():
                    self.averages[test_date] = {}
                    self.averages[test_date][MATH_TYPE] = []
                    self.averages[test_date][READING_TYPE] = []
                    self.averages[test_date][WRITING_TYPE] = []

                user_test = Scored_Test(test_id)
                user_test.date = row[TEST_DATE_INDEX]
                self.averages[test_date][WRITING_TYPE].append(int(row[WRITING_SCALED]))
                self.averages[test_date][MATH_TYPE].append(int(row[MATH_SCALED]))
                self.averages[test_date][READING_TYPE].append(int(row[READING_SCALED]))
                if (is_int(row[ESSAY_INDEX]) and int(row[ESSAY_INDEX]) > 0):
                    user_test.essay = row[ESSAY_INDEX]
                else:
                    user_test.essay = 1
                test_key = self.key_test(test_id)
                for index in range(SECTION_1, SECTION_10 + 1):
                    array = self.convert_section(index, row[index], test_id, row)
                    #print (array)
                    #print ('\n\n')
                    section_type = test_key[index - DIFFERENCE]
                    if section_type == READING_TYPE or section_type == WRITING_TYPE or section_type == MATH_TYPE:
                        #print(user_test.missed_questions[test_key[index - DIFFERENCE]])
                        #print ('!!!')
                        user_test.missed_questions[test_key[index - DIFFERENCE]] += array
                self.students[SID].tests_taken.append(user_test)
                self.elite_scores[SID].append(self.enter_entry(row))

        for test in self.averages.keys():
            self.averages[test][WRITING_TYPE] = average_array(self.averages[test][WRITING_TYPE])
            self.averages[test][READING_TYPE] = average_array(self.averages[test][READING_TYPE])
            self.averages[test][MATH_TYPE] = average_array(self.averages[test][MATH_TYPE])
        #print(self.averages)

                #if n==2:
                #    break
        new_class('Elite')
        filename = class_directory('Elite') + DIR_SEP + "average.txt"
        array = []
        with open(filename, 'w') as f:
            for key in self.averages:
                array.append("TEST_DATE: " + key + endl)
                array.append("WRITING: " + str(self.averages[key][WRITING_TYPE]) + endl)
                array.append("READING: " + str(self.averages[key][READING_TYPE]) + endl)
                array.append("MATH: " + str(self.averages[key][MATH_TYPE]) + endl)
                array.append(SECTION_SEP + endl)
                array.append(endl)
            f.writelines(array)
            f.close()

        DEBUG = True
        REPORTS = False
        error = 1
        error_array = []
        for student in self.students.keys():
            new_user(student, 'Elite')
            self.students[student].save_user()
            u = load_user(student, user_filename(student,'Elite'), 'Elite')
            if DEBUG:
                test_index = 0
                for test in u.tests_taken:
                    e = self.elite_scores[student][test_index]
                    mistake = False

                    if e.writing_raw_score == test.score_summary.writing_score:
                        test.score_summary.section_scores[WRITING_TYPE] = e.writing_scaled_score

                    if e.writing_scaled_score != test.score_summary.section_scores[WRITING_TYPE]:
                        print("Writing score was incorrect for test " + student + " for test " + test.test_id)
                        print("Elite: " + str(e.writing_scaled_score) + " Excelerate: " + str(test.score_summary.section_scores[WRITING_TYPE]))
                        print("Elite: " + str(e.writing_raw_score) + " Excelerate: " + str(test.score_summary.writing_score))
                        print ("Essay: " + str(test.essay))
                        mistake = True

                    if e.reading_scaled_score != test.score_summary.section_scores[READING_TYPE]:
                        print("Reading score was incorrect for test " + student + " for test " + test.test_id)
                        print("Elite: " + str(e.reading_scaled_score) + " Excelerate: " + str(test.score_summary.section_scores[READING_TYPE]))
                        print("Elite: " + str(e.reading_raw_score) + " Excelerate: " + str(test.score_summary.reading_score))
                        mistake = True

                    if e.math_scaled_score != test.score_summary.section_scores[MATH_TYPE]:
                        print("Math score was incorrect for test " + student + " for test " + test.test_id)
                        print("Elite: " + str(e.math_scaled_score) + " Excelerate: " + str(test.score_summary.section_scores[MATH_TYPE]))
                        print("Elite: " + str(e.math_raw_score) + " Excelerate: " + str(test.score_summary.math_score))
                        mistake = True
                    if mistake:
                        print ("Row Number: " + str(e.number))
                        error_array.append(int(e.number))
                        print ("Error Index: " + str(error))
                        error += 1
                        print (endl)
                    test_index += 1
                    #if not mistake:
                    #    print ("ALL CORRECT" + endl)

            if (REPORTS):
                simple_report(u)
                advanced_report(u)
                section_report(u)
                graph_report(u)
                shutil.copy2('reports.html', 'Users/Elite/' + student)
        print(error_array)
        print("Total Errors: " + str(len(error_array)))

        array = []
        with open('runreport.txt', 'w') as f:
            array.append(str(len(self.invalid_rows)) + endl)
            for row in self.invalid_rows:
                array.append(str(row) + endl)
            f.writelines(array)
            f.close()

            #break
    def valid_row(self, row):
        if 'Test_ID' and 'Student_ID' in row: #first row
            return False
        if row[FORM_CODE] not in self.valid_tests:
            return False
        if row[MATH_INDEX] == '-100' or row[MATH_INDEX] == '0':
            return False
        return True

    def convert_section(self, section_index, results_string, test_id, row):
        section_number = section_index - DIFFERENCE
        question_index = 0
        missed_array = []
        for char in results_string:
            question_index += 1
            q_id = test_id + FIELD_SEP + str(section_number) + FIELD_SEP + str(question_index)
            if char != '+':
                if char == 'O': #left blank
                    entry = (q_id, '?')
                else: #incorrect
                    entry = (q_id, char)
                missed_array.append(entry)
        if self.math_grid(test_id, section_number):
            answer_key = self.convert_grid(test_id, section_number)
            answer_array = []
            for index in range(GRIGHT1, GRIGHT10 + 1):
                result = row[index]
                #print (result)
                if result != '+':
                    q_id = test_id + FIELD_SEP + str(section_number) + FIELD_SEP + str(len(results_string)+(index-18))
                    entry = (q_id, '?')
                    missed_array.append(entry)                    
        return missed_array

    def math_grid(self, test_id, section_id):
        filename = test_directory(test_id) + "/Section " + str(section_id) + CSV 
        if not file_exists(filename):
            return False
        with open(filename, 'rU') as f:
            reader = csv.reader(f)
            for row in reader:
                if row[RANGE_INDEX] == "Y":
                    return True
        return False


    def translate_grid_answer(self, answer, key_answer):
        attempt = None
        if answer == '':
            return 'BLANK','?'
        try:
            if '/' in answer:
                num = answer.split('/')[0]
                sub = answer.split('/')[1]
                attempt = round(div(num, sub),3)
            elif '.' in answer:
                attempt = float(answer)
            else:
                attempt = int(answer)
        except:
            attempt = "A"

        answer = key_answer
        #print (attempt)
        if '(' in answer and ')' in answer:
            answer = answer.replace(' ','')
            answer = answer.replace('(','')
            answer = answer.replace(')','')
            lower_limit = float(answer.split(',')[0])
            upper_limit = float(answer.split(',')[1])
            if attempt >= lower_limit and attempt <= upper_limit:
                return "CORRECT"
        elif attempt == float(answer):
            return "CORRECT"
        #print(attempt)
        return "INCORRECT",str(attempt)


    def convert_grid(self, test_id, section_id):
        array = []
        filename = test_directory(test_id) + "/Section " + str(section_id) + CSV 
        with open(filename, 'rU') as f:
            reader = csv.reader(f)
            for row in reader:
                if row[RANGE_INDEX] == "Y":
                    array.append(row[ANSWER_INDEX])
        return array


    def key_test(self, test_id):
        test_dict = {}
        with open(test_directory(test_id) + DIR_SEP + KEYFILE, 'rU') as f:
            reader = csv.reader(f)
            for row in reader:
                if row != KEY_VECTOR:
                    test_dict[int(row[KEY_INDEX])] = int(row[KEY_TYPE])
        return test_dict

    def enter_entry(self, row):
        entry = Elite_Test_Entry(row[FORM_CODE])
        entry.number = row[0]
        entry.writing_raw_score = int(row[WRITING_INDEX])
        entry.reading_raw_score = int(row[READING_INDEX])
        entry.math_raw_score = int(row[MATH_INDEX])
        entry.writing_scaled_score = int(row[WRITING_SCALED])
        entry.reading_scaled_score = int(row[READING_SCALED])
        entry.math_scaled_score = int(row[MATH_SCALED])
        return entry




                
class Elite_Test_Entry(object):

    def __init__(self, test_id):
        self.id = test_id
        self.number = 0
        self.writing_raw_score = 0
        self.reading_raw_score = 0
        self.math_raw_score = 0
        self.writing_scaled_score = 0
        self.reading_scaled_score = 0
        self.math_scaled_score = 0


def translate_grid_answer(answer, key_answer):
    attempt = None
    if answer == '':
        return 'BLANK','?'
    try:
        if '/' in answer:
            num = answer.split('/')[0]
            sub = answer.split('/')[1]
            attempt = round(div(num, sub),3)
        elif '.' in answer:
            attempt = float(answer)
        else:
            attempt = int(answer)
    except:
        attempt = "A"

    answer = key_answer
    #print (attempt)
    if '(' in answer and ')' in answer:
        answer = answer.replace(' ','')
        answer = answer.replace('(','')
        answer = answer.replace(')','')
        lower_limit = float(answer.split(',')[0])
        upper_limit = float(answer.split(',')[1])
        if attempt >= lower_limit and attempt <= upper_limit:
            return "CORRECT"
    elif attempt == float(answer):
        return "CORRECT"
    #print(attempt)
    return "INCORRECT",attempt

#translate_grid_answer()



#convert_database('Elite/elite.csv')
#key_test('GB30')
#convert_section(8, "+++++DC+CO++++++++E++OO+E++EC++D+OO", "GB30")
a = Elite_Class('Elite/Elite.csv')
